pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
max(pred[new_data$y == 0]) < min(pred[new_data$y == 1])
max(pred[new_data$y == 0])
min(pred[new_data$y == 1])
external_sizes <- c(25, 30)
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
external_sizes <- c(20, 30)
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
max(pred[new_data$y == 0]) < min(pred[new_data$y == 1])
max(pred[new_data$y == 0])
min(pred[new_data$y == 1])
cox_calibration <- function(y, prob){
if (max(p[y == 0]) < min(p[y == 1])){
return(list(slope = NA, intercept = NA))
}
dat <- data.frame(e = prob, o = y)
dat$e[dat$e < 0.0000000001] = 0.0000000001
dat$e[dat$e > 0.9999999999] = 0.9999999999
dat$logite <- logit(dat$e)
mfit = glm(formula = o~logite,
family = binomial(link = "logit"), dat)
return(list(slope = as.numeric(mfit$coefficients[2]),
intercept = as.numeric(mfit$coefficients[1])))
}
external_sizes <- c(10, 30)
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
cox_calibration <- function(y, prob){
if (max(prob[y == 0]) < min(prob[y == 1])){
return(list(slope = NA, intercept = NA))
}
dat <- data.frame(e = prob, o = y)
dat$e[dat$e < 0.0000000001] = 0.0000000001
dat$e[dat$e > 0.9999999999] = 0.9999999999
dat$logite <- logit(dat$e)
mfit = glm(formula = o~logite,
family = binomial(link = "logit"), dat)
return(list(slope = as.numeric(mfit$coefficients[2]),
intercept = as.numeric(mfit$coefficients[1])))
}
external_sizes <- c(10, 30)
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
for(ss_index in 1:length(external_sizes)){
sample_size <- external_sizes[ss_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, ss_index] <- cox_cal[1]
intercept_df[i, ss_index] <- cox_cal[2]
}
}
slope_df
options(0)
options(warn=0)
external_sample_sizes
paste("n_", external_sample_sizes, sep = "")
generate_data <- function(n, beta){
n_pred <- length(beta) - 1 #numper of predictors
x <- matrix(rnorm(n*n_pred), n, n_pred) #generated x
design_matrix <- cbind(1, x)
p <- as.numeric(1/(1+exp(- design_matrix %*% beta))) #true probabilities from logit model
y <- rbinom(n, 1, p) #drawing outcomes from Bernoulli distribution
dat <- as.data.frame(x)
dat$y <- y; dat$p <- p
return(dat)
}
logit <- function (p) log(p/(1 - p))
cox_calibration <- function(y, prob){
if (max(prob[y == 0]) < min(prob[y == 1])){
return(list(slope = NA, intercept = NA))
}
dat <- data.frame(e = prob, o = y)
dat$e[dat$e < 0.0000000001] = 0.0000000001
dat$e[dat$e > 0.9999999999] = 0.9999999999
dat$logite <- logit(dat$e)
mfit = glm(formula = o~logite,
family = binomial(link = "logit"), dat)
return(list(slope = as.numeric(mfit$coefficients[2]),
intercept = as.numeric(mfit$coefficients[1])))
}
simulate_different_sample_size <- function(n_sim, external_sizes){
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
names(slope_df) <- paste("n_", external_sample_sizes, sep = "")
names(intercept_df) <- paste("n_", external_sample_sizes, sep = "")
for(es_index in 1:length(external_sizes)){
sample_size <- external_sizes[es_index]
for (i in 1:n_sim){
full_data <- generate_data(n, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, es_index] <- cox_cal[1]
intercept_df[i, es_index] <- cox_cal[2]
}
}
return(list(slope = slope_df, intercept = intercept_df))
}
generate_data <- function(n, beta){
n_pred <- length(beta) - 1 #numper of predictors
x <- matrix(rnorm(n*n_pred), n, n_pred) #generated x
design_matrix <- cbind(1, x)
p <- as.numeric(1/(1+exp(- design_matrix %*% beta))) #true probabilities from logit model
y <- rbinom(n, 1, p) #drawing outcomes from Bernoulli distribution
dat <- as.data.frame(x)
dat$y <- y; dat$p <- p
return(dat)
}
logit <- function (p) log(p/(1 - p))
cox_calibration <- function(y, prob){
if (max(prob[y == 0]) < min(prob[y == 1])){
return(list(slope = NA, intercept = NA))
}
dat <- data.frame(e = prob, o = y)
dat$e[dat$e < 0.0000000001] = 0.0000000001
dat$e[dat$e > 0.9999999999] = 0.9999999999
dat$logite <- logit(dat$e)
mfit = glm(formula = o~logite,
family = binomial(link = "logit"), dat)
return(list(slope = as.numeric(mfit$coefficients[2]),
intercept = as.numeric(mfit$coefficients[1])))
}
simulate_different_sample_size <- function(n_sim, external_sizes, beta, n_training){
n <- 100
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
names(slope_df) <- paste("n_", external_sample_sizes, sep = "")
names(intercept_df) <- paste("n_", external_sample_sizes, sep = "")
for(es_index in 1:length(external_sizes)){
sample_size <- external_sizes[es_index]
for (i in 1:n_sim){
full_data <- generate_data(n_training, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, es_index] <- cox_cal[1]
intercept_df[i, es_index] <- cox_cal[2]
}
}
return(list(slope = slope_df, intercept = intercept_df))
}
n_training <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
n_sim <- 1000
external_sample_sizes <- c(20, 50, 100, 200, 500,1000, 2000)
sim_results <- simulate_different_sample_size(n_sim, external_sample_sizes,
beta, n_training)
expected_slope <- apply(sim_results$slope, 2, mean)
expected_slope
apply(sim_results$intercept, 2, mean, na.rm=TRUE)
expected_slope <- apply(sim_results$slope, 2, mean, na.rm=TRUE)
expected_slope
options(warn = 2)
external_sizes <- c(15, 30, 50)
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
names(slope_df) <- paste("n_", external_sample_sizes, sep = "")
names(intercept_df) <- paste("n_", external_sample_sizes, sep = "")
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
names(slope_df) <- paste("n_", external_sizes, sep = "")
names(intercept_df) <- paste("n_", external_sizes, sep = "")
for(es_index in 1:length(external_sizes)){
sample_size <- external_sizes[es_index]
for (i in 1:n_sim){
full_data <- generate_data(n_training, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
new_data <- generate_data(sample_size, beta)
pred <- predict(logitm, new_data, type="response")
cox_cal <- cox_calibration(new_data$y, pred)
slope_df[i, es_index] <- cox_cal[1]
intercept_df[i, es_index] <- cox_cal[2]
}
}
pred
max(pred[new_data$y == 0]) < min(pred[new_data$y == 1])
max(pred[new_data$y == 0])
min(pred[new_data$y == 1])
cox_cal <- cox_calibration(new_data$y, pred)
options(warn = 0)
cox_cal <- cox_calibration(new_data$y, pred)
cox_cal
pred
new_data$y
set.seed(26042021)
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
full_data <- generate_data(n, beta)
#fitting the model
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
summary(logitm)
pred <- predict(logitm, new_data, type="response")
cox_calibration(full_data$y, pred)
pred
cox_calibration(full_data$y, pred)
full_data$y
cox_calibration(new_data$y, pred)
new_data$y
pref
pred
dat <- data.frame(e = pred, o = new_data$y)
View(dat)
dat[dat$o == 1]
dat[dat$o == 1,]
dat[dat$o == 0,]
set.seed(26042021)
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
full_data <- generate_data(n, beta)
#fitting the model
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
summary(logitm)
pred <- predict(logitm, new_data, type="response")
cox_calibration(full_data$y, pred)
new_data <- generate_data(n, beta)
pred <- predict(logitm, new_data, type="response")
external_data <- generate_data(n, beta)
pred <- predict(logitm, external_data, type="response")
cox_calibration(external_data$y, pred)
ggplot(stack(sim_results$slope), aes(x = ind, y = values)) +
geom_boxplot()
ggplot(stack(sim_results$slope[,2:7]), aes(x = ind, y = values)) +
geom_boxplot()
expected_intercept <- apply(sim_results$intercept, 2, mean, na.rm=TRUE)
expected_intercept
median_slope <- apply(sim_results$slope, 2, median, na.rm=TRUE)
median_slope
slope_df <- stack(sim_results$slope[c("n_50", "n_200", "n_1000")])
ggplot(slope_df, aes(x = values, fill = ind)) +
geom_histogram(position = "identity", alpha = 0.3, bins = 50)
expected_slope
set.seed(15081924)
n_training <- 100 #relatively small sample size but EPV > 10
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
n_sim <- 1000 #Running it with bigger sample gives similar results
external_sample_sizes <- c(20, 50, 100, 200, 500, 1000, 2000)
sim_results <- simulate_different_sample_size(n_sim, external_sample_sizes,
beta, n_training)
expected_slope <- apply(sim_results$slope, 2, mean, na.rm=TRUE)
expected_intercept <- apply(sim_results$intercept, 2, mean, na.rm=TRUE)
max(sim_results$slope)
max(sim_results$slope, na.rm = TRUE)
expected_slope <- apply(sim_results$slope, 2, mean, na.rm=TRUE)
expected_slope
sum(is.na(sim_results$slope$n_20))
sum(is.na(sim_results$slope$n_50))
(expected_slope <- apply(sim_results$slope, 2, mean, na.rm=TRUE))
(expected_intercept <- apply(sim_results$intercept, 2, mean, na.rm=TRUE))
(median_slope <- apply(sim_results$slope, 2, median, na.rm=TRUE))
(median_intercept <- apply(sim_results$intercept, 2, median, na.rm = TRUE))
ggplot(stack(sim_results$slope[,2:7]), aes(x = ind, y = values)) +
geom_boxplot()
set.seed(15081924)
n_training <- 100 #relatively small sample size but EPV > 10
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
n_sim <- 1000 #Running it with bigger sample gives similar results
external_sample_sizes <- c(20, 50, 100, 200, 500, 1000, 2000)
sim_results <- simulate_different_sample_size(n_sim, external_sample_sizes,
beta, n_training)
sum(is.na(sim_results$slope$n_20))
sum(is.na(sim_results$slope$n_50))
(expected_slope <- apply(sim_results$slope, 2, mean, na.rm = TRUE))
set.seed(26042021)
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
full_data <- generate_data(n, beta)
sum(full_data$y)
sum(full_data$y)
#fitting the model
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
summary(logitm)
external_data <- generate_data(n, beta)
pred <- predict(logitm, external_data, type="response")
cox_calibration(external_data$y, pred)
set.seed(26042021)
n <- 100
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
full_data <- generate_data(n, beta)
sum(full_data$y)
#fitting the model
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
summary(logitm)
external_data <- generate_data(n, beta)
pred <- predict(logitm, external_data, type="response")
cox_calibration(external_data$y, pred)
simulate_different_sample_size <- function(n_sim, external_sizes, beta, n_training){
slope_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
intercept_df <- as.data.frame(matrix(NA, n_sim, length(external_sizes)))
names(slope_df) <- paste("n_", external_sizes, sep = "")
names(intercept_df) <- paste("n_", external_sizes, sep = "")
for(es_index in 1:length(external_sizes)){
sample_size <- external_sizes[es_index]
for (i in 1:n_sim){
full_data <- generate_data(n_training, beta)
logitm <- glm(y ~. -p, family = "binomial", data = full_data)
external_data <- generate_data(sample_size, beta)
pred <- predict(logitm, external_data, type="response")
cox_cal <- cox_calibration(external_data$y, pred)
slope_df[i, es_index] <- cox_cal[1]
intercept_df[i, es_index] <- cox_cal[2]
}
}
return(list(slope = slope_df, intercept = intercept_df))
}
set.seed(15081924)
n_training <- 100 #relatively small sample size but almost always EPV > 10
beta <- c(-0.3, 1, -1, .3) #using 3 predictors
n_sim <- 1000 #Running it with bigger sample gives similar results
external_sample_sizes <- c(20, 50, 100, 200, 500, 1000, 2000)
sim_results <- simulate_different_sample_size(n_sim, external_sample_sizes,
beta, n_training)
set.seed(1337)
n_training <- 100 #relatively small sample size but almost always EPV > 10
sum(is.na(sim_results$slope$n_20))
#for n > 20, it it zero
sum(is.na(sim_results$slope)) - sum(is.na(sim_results$slope$n_20))
hist(sim_results$slope$n_20)
hist(sim_results$slope$n_20, 50)
#strongly skewed so omitted from next plot
ggplot(stack(sim_results$slope[,2:7]), aes(x = ind, y = values)) +
geom_boxplot()
(expected_slope <- apply(sim_results$slope, 2, mean, na.rm = TRUE))
(median_slope <- apply(sim_results$slope, 2, median, na.rm = TRUE))
(expected_slope <- apply(sim_results$slope, 2, mean, na.rm = TRUE))
(median_slope <- apply(sim_results$slope, 2, median, na.rm = TRUE))
(expected_intercept <- apply(sim_results$intercept, 2, mean, na.rm = TRUE))
(median_intercept <- apply(sim_results$intercept, 2, median, na.rm = TRUE))
hist(sim_results$slope$n_20, 50)
#strongly skewed so omitted from next plot
ggplot(stack(sim_results$slope[,2:7]), aes(x = ind, y = values)) +
geom_boxplot()
slope_df <- stack(sim_results$slope[c("n_50", "n_200", "n_1000")])
ggplot(slope_df, aes(x = values, fill = ind)) +
geom_histogram(position = "identity", alpha = 0.3, bins = 50)
n_training <- 1000
sim_results_big_training <- simulate_different_sample_size(n_sim,
external_sample_sizes, beta, n_training)
apply(sim_results_big_training$slope, 2, mean, na.rm = TRUE))
apply(sim_results_big_training$slope, 2, mean, na.rm = TRUE)
ggplot(stack(sim_results_big_training$slope[,2:7]), aes(x = ind, y = values)) +
geom_boxplot()
(expected_intercept <- apply(sim_results$intercept, 2, mean, na.rm = TRUE))
(median_intercept <- apply(sim_results$intercept, 2, median, na.rm = TRUE))
plot(expected_intercept)
hist(sim_results$slope$n_20, 50)
#strongly skewed so omitted from the next plot
ggplot(stack(sim_results$slope[,2:7]), aes(x = ind, y = values)) +
geom_boxplot()
slope_df <- stack(sim_results$slope[c("n_50", "n_200", "n_1000")])
ggplot(slope_df, aes(x = values, fill = ind)) +
geom_histogram(position = "identity", alpha = 0.3, bins = 50)
Sys.info()
Sys.info()['sysname']
if (Sys.info()['sysname'] == "Windows") on_cluster <- TRUE
else on_cluster <- FALSE
if (Sys.info()['sysname'] == "Windows") {on_cluster <- TRUE
}else on_cluster <- FALSE
if (Sys.info()['sysname'] == "Windows") {on_cluster <- TRUE
} else {on_cluster <- FALSE}
on_cluster
Sys.info()['sysname'] == "Windows"
on_cluster <- !(Sys.info()['sysname'] == "Windows")
on_cluster
on_cluster <- Sys.info()['sysname'] == "Linux"
on_cluster
doParallel::registerDoParallel(cores = cores)
cores <- if(on_cluster) Sys.getenv(paste("SLURM_CPUS_PER_TASK")) else 4
cores
doParallel::registerDoParallel(cores = cores)
setwd("~/MustMast/Thesis/Code")
source("validation_techniques.R")
source("data_generation.R")
library(foreach)
on_cluster <- Sys.info()['sysname'] == "Linux"
cores <- if(on_cluster) Sys.getenv(paste("SLURM_CPUS_PER_TASK")) else 4
doParallel::registerDoParallel(cores = cores)
performance_measures <- create_performance_measures_list()
models_list <- list(llm = logistic_model, lda = lda_model)
set.seed(11011906)
n <- 1000
n <- 100
beta <- c(-0.3, 1, -1, .3)
results <- foreach(i=4:1) %dopar% {
full_data <- generate_data_from_logistic(n, beta)
kfold_result <- kfold_CV(full_data, performance_measures, models_list)
RCV_results <- repeated_CV(full_data, performance_measures, models_list)
bootstrap_results <- bootstrap_methods(full_data, performance_measures, models_list, b = 100)
result <- rbind(kfold_result, RCV_results, bootstrap_results)
result
}
results
